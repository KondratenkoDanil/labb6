#include <iostream>

int main() { // Зміна void на int
    long X = 2; // Початкове значення x (можете змінити на 3, якщо потрібно)
    long REZ[7]; // Масив для результатів

    __asm { // Початок асемблерної вставки
        lea EBX, REZ // Завантаження адреси результатів в регістр EBX
        mov ECX, 7 // Рахівник кількості повторень циклу

        m1:
        mov EAX, X // Завантаження x в EAX
            imul EAX, EAX // EAX = x^2
            imul EAX, 4 // EAX = 4 * x^2
            sub EAX, 12 // EAX = 4 * x^2 - 12
            mov EDI, X // Завантаження x в EDI
            imul EDI, EDI // EDI = x^2
            imul EDI, 5 // EDI = 5 * x^2
            add EDI, 8 // EDI = 5 * x^2 + 8

            cdq // Розширення EAX в EDX:EAX для ділення
            idiv EDI // Ділимо EAX на EDI (EAX / EDI), результат в EAX, залишок в EDX

            // Округлення результату
            cmp EDX, 0 // Перевірка залишку
            jz no_rounding // Якщо залишок 0, не потрібно округлювати
            add EAX, 1 // Якщо залишок > 0, округлюємо вгору

            no_rounding:
        mov[EBX], EAX // Запис результату в пам'ять
            add EBX, 4 // Збільшення адреси результатів
            add X, 3 // Збільшення аргументу x
            loop m1 // Зациклювання по рахівнику в ECX
    } // Закінчення асемблерної вставки

    // Виведення результатів на екран
    for (int i = 0; i < 7; ++i) {
        std::cout << "Результат " << (i + 1) << ": " << REZ[i] << std::endl;
    }

    return 0; // Повертаємо 0
}
